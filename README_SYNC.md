# スケジュールデータ同期機能

`main.py`にスマートなデータ同期機能を実装しました。Cybozuから取得したデータと`schedule.json`の差分を検知して、自動的に追加・更新・削除を行います。

## 🔄 同期の仕組み

### 1. **変更なし** → スキップ
既存のデータと完全に同じ場合は、何もせずスキップします。

```
Cybozu: 営業会議 10:00-12:00 (会議)
JSON:   営業会議 10:00-12:00 (会議)
→ 結果: スキップ（変更なし）
```

### 2. **変更あり** → 更新
タイトル、時間、バッジのいずれかに変更がある場合、データを更新します。

```
Cybozu: 営業会議 10:00-13:00 (会議)  ← 終了時刻が変更
JSON:   営業会議 10:00-12:00 (会議)
→ 結果: 更新（終了時刻を13:00に変更）
```

**重要**: IDと参加者情報は保持されます！

### 3. **新規追加** → 追加
JSONに存在しない予定がCybozuにある場合、新規追加します。

```
Cybozu: 新規打ち合わせ 14:00-15:00 (来訪)
JSON:   （存在しない）
→ 結果: 追加（新しいIDを付与）
```

### 4. **削除検出** → 削除
JSONにある予定がCybozuから削除された場合、JSONからも削除します。

```
Cybozu: （存在しない）
JSON:   古い予定 16:00-17:00 (会議)
→ 結果: 削除（Cybozuから削除されたため）
```

## 📊 比較対象のフィールド

変更検知には以下のフィールドを使用します：

| フィールド | 説明 | 例 |
|-----------|------|-----|
| `title` | 予定のタイトル | 営業会議 |
| `start_datetime` | 開始時刻 | 10:00 |
| `end_datetime` | 終了時刻 | 12:00 |
| `badge` | バッジ | 会議、来訪、WEB会議 |

## 🔐 保持されるデータ

更新時に以下のデータは保持されます：

| フィールド | 説明 | 理由 |
|-----------|------|------|
| `id` | 予定のID | 一意性を保つため |
| `participants` | 参加者リスト | 別途取得するため |

## 💡 使用例

### 例1: 初回実行（すべて新規追加）

```bash
python main.py
```

出力:
```
施設「社長室」の2025-11-05のスケジュールにアクセス中...
  2025-11-05: 営業会議 を追加
  2025-11-05: 打ち合わせ を追加
  2025-11-10: 全社会議 を追加
```

### 例2: 2回目実行（変更なし）

```bash
python main.py
```

出力:
```
施設「社長室」の2025-11-05のスケジュールにアクセス中...
  2025-11-05: 営業会議 は変更なし
  2025-11-05: 打ち合わせ は変更なし
  2025-11-10: 全社会議 は変更なし
```

### 例3: 時間が変更された場合

Cybozuで「営業会議」の終了時刻を12:00→13:00に変更

```bash
python main.py
```

出力:
```
施設「社長室」の2025-11-05のスケジュールにアクセス中...
  2025-11-05: 営業会議 を更新
  2025-11-05: 打ち合わせ は変更なし
  2025-11-10: 全社会議 は変更なし
```

`schedule.json`の該当予定:
```json
{
  "title": "営業会議",
  "start_datetime": "10:00",
  "end_datetime": "13:00",  // ← 更新された
  "badge": "会議",
  "id": 1,  // ← 保持
  "participants": ["山田太郎", "鈴木花子"]  // ← 保持
}
```

### 例4: 新規予定の追加

Cybozuで新しく「進捗確認」を追加

```bash
python main.py
```

出力:
```
施設「社長室」の2025-11-05のスケジュールにアクセス中...
  2025-11-05: 営業会議 は変更なし
  2025-11-05: 打ち合わせ は変更なし
  2025-11-05: 進捗確認 を追加  // ← 新規追加
  2025-11-10: 全社会議 は変更なし
```

### 例5: 予定の削除

Cybozuから「打ち合わせ」を削除

```bash
python main.py
```

出力:
```
施設「社長室」の2025-11-05のスケジュールにアクセス中...
  2025-11-05: 営業会議 は変更なし
  2025-11-05: 進捗確認 は変更なし
  2025-11-05: 打ち合わせ を削除（Cybozuから削除されました）  // ← 削除
  2025-11-10: 全社会議 は変更なし
```

### 例6: 複合的な変更

- 「営業会議」のタイトルを「営業定例会」に変更
- 「進捗確認」を削除
- 「新規研修」を追加

```bash
python main.py
```

出力:
```
施設「社長室」の2025-11-05のスケジュールにアクセス中...
  2025-11-05: 営業定例会 を更新  // ← タイトル変更
  2025-11-05: 新規研修 を追加     // ← 新規追加
  2025-11-05: 進捗確認 を削除（Cybozuから削除されました）  // ← 削除
  2025-11-10: 全社会議 は変更なし
```

## 🎯 メリット

### 1. **効率的な実行**
- 変更のないデータは処理をスキップ
- 不要なデータ書き込みを削減

### 2. **データの一貫性**
- CybozuとJSONが常に同期
- 削除された予定も自動的に削除

### 3. **IDの保持**
- 既存の予定のIDは変更されない
- 他のシステムとの連携が容易

### 4. **参加者情報の保持**
- 更新時に参加者情報は保持される
- 参加者情報の再取得は最後に一括実行

### 5. **詳細なログ**
- どの予定が追加/更新/削除されたか明確
- トラブルシューティングが容易

## 📝 技術的な詳細

### URLによる一意識別

各予定は`description_url`で一意に識別されます：

```python
"description_url": "https://9w4c9.cybozu.com/o/ag.cgi?page=ScheduleView&UID=340&GID=&Date=da.2025.11.5&BDate=da.2025.11.5&sEID=135146&CP=sg&BK=1"
```

このURLが同じ場合、同じ予定として扱われます。

### 変更検知のロジック

```python
has_changes = (
    existing_event.get('title') != new_event['title'] or
    existing_event.get('start_datetime') != new_event['start_datetime'] or
    existing_event.get('end_datetime') != new_event['end_datetime'] or
    existing_event.get('badge') != new_event['badge']
)
```

### 更新時のデータ保持

```python
# IDとparticipantsを保持
event_id = existing_event.get('id')
participants = existing_event.get('participants', [])

# データを更新
existing_event.update({
    'title': new_event['title'],
    'start_datetime': new_event['start_datetime'],
    'end_datetime': new_event['end_datetime'],
    'badge': new_event['badge'],
    'description_url': new_event['description_url']
})

# IDとparticipantsを復元
if event_id:
    existing_event['id'] = event_id
if participants:
    existing_event['participants'] = participants
```

### 削除検出のロジック

```python
# 新しく取得したイベントのURLセット
new_event_urls = {event['description_url'] for event in event_list}

# 既存イベントが新しいセットに含まれていない場合は削除
for existing_event in schedule_data[search_term][event_date]:
    event_url = existing_event.get('description_url')
    if event_url and event_url not in new_event_urls:
        # 削除対象
        events_to_remove.append(existing_event)
```

## 🔄 実行フロー

```
1. Cybozuからスケジュールデータを取得
   ↓
2. schedule.jsonを読み込み
   ↓
3. 各予定について：
   ├─ URLで既存予定を検索
   ├─ 存在する？
   │  ├─ Yes → 内容を比較
   │  │  ├─ 変更あり → 更新（IDと参加者は保持）
   │  │  └─ 変更なし → スキップ
   │  └─ No → 新規追加（新しいIDを付与）
   ↓
4. 削除された予定を検出
   ├─ JSONにあるがCybozuにない予定を検索
   └─ 該当する予定をJSONから削除
   ↓
5. schedule.jsonに保存
   ↓
6. 参加者情報を取得（別処理）
```

## ⚠️ 注意事項

### 週単位の取得

プログラムは週表示でデータを取得するため：

- **取得した週の日付のみ**が同期対象
- 取得していない日付のデータは保持される
- 過去のデータは削除されない

### 参加者情報の取得タイミング

参加者情報は以下のタイミングで取得されます：

1. **予定データの同期** → schedule.jsonに保存
2. **参加者情報の取得** → 各予定の詳細ページにアクセス
3. **最終保存** → 参加者情報を含めて保存

これにより、予定の更新時に参加者情報が失われることを防ぎます。

### IDの採番

- 新規追加時は既存の最大ID + 1
- 更新時はIDを保持
- 削除してもIDは再利用されない

## 🐛 トラブルシューティング

### 変更が反映されない

**症状**: Cybozuで変更したのにJSONが更新されない

**原因**:
- 対象の週を取得していない可能性
- URLが変更された（別の予定として扱われる）

**対処**:
```bash
# 該当する週を含めて再取得
python main.py
```

### 予定が重複する

**症状**: 同じ予定が複数登録される

**原因**:
- URLが異なる（Cybozuで予定を作り直した可能性）

**対処**:
```bash
# schedule.jsonをバックアップ
copy schedule.json schedule.json.bak

# JSONを削除して再取得
del schedule.json
python main.py
```

### IDが変わってしまった

**症状**: 既存の予定のIDが変更された

**原因**:
- schedule.jsonが削除された
- URLが変更された

**対処**:
- バックアップから復元
- IDの再マッピングが必要な場合は手動調整

## 📈 今後の改善案

1. **差分レポート**
   - 追加/更新/削除の統計を出力
   - 変更履歴をログファイルに保存

2. **バックアップ機能**
   - 更新前に自動バックアップ
   - ロールバック機能

3. **競合解決**
   - タイムスタンプによる競合検出
   - マージ戦略の選択

4. **増分同期**
   - 変更があった日付のみ処理
   - 実行時間の短縮

5. **通知機能**
   - 大きな変更があった場合にメール通知
   - Slackなどへの通知

